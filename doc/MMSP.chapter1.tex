% MMSP.chapter1.tex

\chapter{Introduction}
The goal of the Mesoscale Microstructure Simulation Project (\MMSP) is to provide a simple, consistent, and extensible programming interface for all grid and mesh based microstructure evolution methods. Simple means that the package has a very small learning curve, and for most routine simulations, only a minimal amount of code must be written. By consistent we mean, for example, that code for two-dimensional simulations is nearly identical to that for three-dimensional simulations, single processor programs are easily parallelized, and fundamentally different methods like Monte Carlo or phase field have the same look and feel. Finally, extensible means that it's straightforward to add new grid types or physical behaviors to the package. Other considerations include efficiency and portability (\MMSP is written entirely in ISO compliant {\tt c++}).

\section{The \MMSP concept}
The design of \MMSP is based on several observations about how mesoscale simulations are used by materials scientists: most mesoscale simulations discretize the spatial domain using a rectilinear grid. A data structure is associated with each grid node that has a particular size (scalar, vector, etc.) and value type (integer, floating point) depending on the simulation method. Most simulations update the data structure at each node in a way that falls under some common methodology (Monte Carlo, phase field, etc.) but has features unique to each given physical process.  What this roughly means is that most mesoscale simulations use a common spatial discretization, but we usually need to tweak the details of how we represent spatial data and how we update it. The unfortunate truth is that typically, a researcher wishing to model a particular physical process produces code with a focus mainly on the particulars of the process itself (the ``tweak''), largely ignoring the problem of how to design reusable data structures. What happens when they decide they should try a different simulation method, or when they realize that they need to use a parallel implementation?  It then becomes apparent that more flexible data structures should have been used in the first place.  The purpose of \MMSP is to provide the core functionality that we don't necessarily want to think about each time we program a new method.  \MMSP helps keep its users from reinventing grid data structures, file input and output, parallelization, handling boundary conditions, etc.\ while retaining enough flexibility to model a large number of physical processes.

Those familiar with similar code packages might have already noticed that the \MMSP concept is a bit unusual. Other packages typically provide a very high level interface intended for use with a {\em single} computational method.  Using the interface typically means learning package-specific methodology, classes, functions, methods, etc.  In contrast, \MMSP is meant to be used for any and all grid-based methods, and provides a much lower level interface.  This results in a lot more flexibility in what \MMSP can do.  And while \MMSP still requires some learning, users will find that they are able to leverage much more of their previous programming experience.

\section{What \MMSP does}
\MMSP is nothing more than a collection of {\tt c++} header files that declare a number of {\tt grid} objects (classes) and define how most of their methods (member functions) are implemented.  Some things \MMSP provides include:
\begin{itemize}
\item A simple, extensible programming interface
\item Computational grids of arbitrary dimension
\item Parallel implementations using MPI
\item Automatic, optimal parallel mesh topologies
\item Utility programs for grid visualization
\item Classes for Monte Carlo methods
\item Classes for cellular automata methods 
\item Classes for phase field methods (conventional)
\item Classes for phase field methods (sparsePF)
\item Classes for general finite difference PDE solvers
\item Example simulation methods and grid objects
\end{itemize}

\section{What \MMSP doesn't do}
\MMSP is not the kind of software that reads a few parameters or an input file specified by the user and cranks out some generic computation. In fact, \MMSP relies on the user to provide code for all of the real physics that the simulation is intended to capture. This isn't as scary as it sounds. \MMSP was designed to make this procedure as simple as possible. The takeaway message here is that \MMSP makes programming materials simulation code easier, but it isn't a ``black box'' that can be used by a complete novice.

\section{What \MMSP requires}
The \MMSP interface is intended to look and feel very natural for most programmers with experience in scientific computing.  While many of the most advanced features of {\tt c++} have been used in creating the grid and data classes, the user need not be proficient in anything other than basic procedural programming.  {\tt Fortran}, {\tt c}, and novice {\tt c++} programmers alike will find that \MMSP is quite easy to use.  Basic requirements include:
\begin{itemize}
\item Minimal programming experience
\item A {\tt c++} compiler with ISO compliant libraries and headers (e.g. {\tt gcc} 2.95 or later)
\item MPI libraries are required if compiling parallel programs (e.g. OpenMPI)
\end{itemize}

\section{Terms of use}
\MMSP is freely available for anyone performing non--profit scientific research; those interested in using \MMSP for any other purposes should contact the author. We give no guarantees whatsoever about the capabilities of \MMSP. If you use \MMSP in your research, please tell others about it, send us any new code you'd like to see incorporated into the package, and above all, give us feedback! 

